{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Heqet \u00b6 Heqet (Egyptian \u1e25qt, also \u1e25qtyt \"Heqtit\") is an Egyptian goddess of fertility. Heqet is my attempt to make Kubernetes GitOps Deployments as easy as possible. It reduces the need of configuration by generating the required Application definitions for you. Heqet heavily relies on a Helm-Chart which will generate all applications, namespaces & more using ArgoCDs App-of-Apps-Pattern . Keyfeatures \u00b6 Easy Setup [Sane Kubernetes cluster + PVC-StorageClass] Easy application definition & configuration Follows the GitOps principles Deploy a whole application environment or cluster from a singe git-repo This project is still in a very early stage of development, but feel free to try it out & contribute! Overview \u00b6 Components & Configuration \u00b6 Core component is ArgoCD which will deploy Heqet & also your apps! All you need is a git-repo & k8s cluster. The heqet Helm-Chart will generate ArgoCD Applications, namespaces and if required vault Secrets. All you need to do if add your Helm-Application to heqet's values.yaml . If more configuration values are required, simply throw your applications values.yaml into heqets values.d folder, named as the application [e.g. values.d/argocd.yaml . Installation \u00b6 Installing heqet can't be simpler, after configuring your apps, argocd and pushing it to your git repo: Configure manifests/heqet-apps.yaml to match your Setup kubectl apply -f manifests/argocd.yaml kubectl apply -f manifests/heqet-apps.yaml ArgoCD will start and bootstrap heqet. Example Configuration \u00b6 Check out the test -branch of the heqet repository for the latest deployment configuration in my test environment.","title":"Heqet"},{"location":"#heqet","text":"Heqet (Egyptian \u1e25qt, also \u1e25qtyt \"Heqtit\") is an Egyptian goddess of fertility. Heqet is my attempt to make Kubernetes GitOps Deployments as easy as possible. It reduces the need of configuration by generating the required Application definitions for you. Heqet heavily relies on a Helm-Chart which will generate all applications, namespaces & more using ArgoCDs App-of-Apps-Pattern .","title":"Heqet"},{"location":"#keyfeatures","text":"Easy Setup [Sane Kubernetes cluster + PVC-StorageClass] Easy application definition & configuration Follows the GitOps principles Deploy a whole application environment or cluster from a singe git-repo This project is still in a very early stage of development, but feel free to try it out & contribute!","title":"Keyfeatures"},{"location":"#overview","text":"","title":"Overview"},{"location":"#components-configuration","text":"Core component is ArgoCD which will deploy Heqet & also your apps! All you need is a git-repo & k8s cluster. The heqet Helm-Chart will generate ArgoCD Applications, namespaces and if required vault Secrets. All you need to do if add your Helm-Application to heqet's values.yaml . If more configuration values are required, simply throw your applications values.yaml into heqets values.d folder, named as the application [e.g. values.d/argocd.yaml .","title":"Components &amp; Configuration"},{"location":"#installation","text":"Installing heqet can't be simpler, after configuring your apps, argocd and pushing it to your git repo: Configure manifests/heqet-apps.yaml to match your Setup kubectl apply -f manifests/argocd.yaml kubectl apply -f manifests/heqet-apps.yaml ArgoCD will start and bootstrap heqet.","title":"Installation"},{"location":"#example-configuration","text":"Check out the test -branch of the heqet repository for the latest deployment configuration in my test environment.","title":"Example Configuration"},{"location":"appconfig/","text":"Application Definition \u00b6 Here is a list of available configuration options inside the apps array of heqets values.yaml . Required \u00b6 Parameter Type Example Description name string \"argocd\" Name of your application & namespace [if not specified] repoURL string \"https://github.com/nold360/heqet\" URL to git or Helmchart repo path string \"charts/heqet\" Path to chart if using git in repoURL chart string \"heqet\" Chart name [ only use either path or chart ] targetRevision string \"1.2.3\" or \"master\" Version of Helm-Chart or Branch/Tag of git Optional \u00b6 Parameter Type Default Example Description disabled bool false true Disable App existingNamespace string none \"default\" Don't create namespace, instead use an existing one namespace string .Values.name \"superns\" Name of application namespace annotations hash my.anno.org/stuff: is-awesome Namespace annotations syncWave string \"0\" `\"-2\" ArgoCD SyncWave project string \"heqet\" \"myproject\" Name of ArgoCD Project server string \"https://kubernetes.default.svc\" https://my.external.cluster:8443 K8s Cluster to deploy to prune bool false true ArgoCD automatic prune app selfHeal bool false true ArgoCD automatic self-heal app ignoreDiff array See ArgoCD docs ArgoCD ignoreDifferences parameters array - name: ingress.host value: awesome.url Parameters override values of app Custom Resource Definitions \u00b6 CRDs might be required before applying application configuration. If so, copy the crd.yaml into the /crds -Directory. Full Example \u00b6 Check out the test -Branch of this repo for my current testing setup.","title":"Appconfig"},{"location":"appconfig/#application-definition","text":"Here is a list of available configuration options inside the apps array of heqets values.yaml .","title":"Application Definition"},{"location":"appconfig/#required","text":"Parameter Type Example Description name string \"argocd\" Name of your application & namespace [if not specified] repoURL string \"https://github.com/nold360/heqet\" URL to git or Helmchart repo path string \"charts/heqet\" Path to chart if using git in repoURL chart string \"heqet\" Chart name [ only use either path or chart ] targetRevision string \"1.2.3\" or \"master\" Version of Helm-Chart or Branch/Tag of git","title":"Required"},{"location":"appconfig/#optional","text":"Parameter Type Default Example Description disabled bool false true Disable App existingNamespace string none \"default\" Don't create namespace, instead use an existing one namespace string .Values.name \"superns\" Name of application namespace annotations hash my.anno.org/stuff: is-awesome Namespace annotations syncWave string \"0\" `\"-2\" ArgoCD SyncWave project string \"heqet\" \"myproject\" Name of ArgoCD Project server string \"https://kubernetes.default.svc\" https://my.external.cluster:8443 K8s Cluster to deploy to prune bool false true ArgoCD automatic prune app selfHeal bool false true ArgoCD automatic self-heal app ignoreDiff array See ArgoCD docs ArgoCD ignoreDifferences parameters array - name: ingress.host value: awesome.url Parameters override values of app","title":"Optional"},{"location":"appconfig/#custom-resource-definitions","text":"CRDs might be required before applying application configuration. If so, copy the crd.yaml into the /crds -Directory.","title":"Custom Resource Definitions"},{"location":"appconfig/#full-example","text":"Check out the test -Branch of this repo for my current testing setup.","title":"Full Example"},{"location":"k3s/","text":"Heqet on K3s \u00b6 Bootstrap K3s \u00b6 See: K3s Install Options Or if you are feeling lucky: curl -sfL https://get.k3s.io | sh - Bootstrap ArgoCD using Helm \u00b6 kubectl apply -f manifests/argocd-helm.yaml --- apiVersion: v1 kind: Namespace metadata: name: argocd --- apiVersion: helm.cattle.io/v1 kind: HelmChart metadata: name: argocd namespace: kube-system spec: chart: argo-cd repo: https://argoproj.github.io/argo-helm targetNamespace: argocd set: configs.secret.argocdServerAdminPassword: \"$2y$10$IuaM9Ad1mPMycjnStOdNc.wjRlLtI8448F/hS.eA0XJLH9r/ZwRv.\" valuesContent: |- controller: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true dex: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true redis: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true server: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true ingress: enabled: true hosts: - argocd.k3s extraArgs: - --insecure reposerver: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true The password in this example is argocd . Bootstrap Heqet \u00b6 kubectl apply -f manifests/heqet-apps.yaml --- apiVersion: v1 kind: Namespace metadata: name: heqet --- apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: heqet namespace: argocd spec: destination: namespace: heqet server: 'https://kubernetes.default.svc' source: path: . repoURL: 'https://github.com/nold360/heqet' targetRevision: test helm: valueFiles: - values.yaml project: default syncPolicy: automated: prune: true selfHeal: false Profit! \u00b6 Now K3s should be setup: ArgoCD should be deployed by K3s-Helm-Operator The Heqet-Application will bootstrap ArgoCD ArgoCD will take control of all Application configuration in heqet","title":"Heqet on K3s"},{"location":"k3s/#heqet-on-k3s","text":"","title":"Heqet on K3s"},{"location":"k3s/#bootstrap-k3s","text":"See: K3s Install Options Or if you are feeling lucky: curl -sfL https://get.k3s.io | sh -","title":"Bootstrap K3s"},{"location":"k3s/#bootstrap-argocd-using-helm","text":"kubectl apply -f manifests/argocd-helm.yaml --- apiVersion: v1 kind: Namespace metadata: name: argocd --- apiVersion: helm.cattle.io/v1 kind: HelmChart metadata: name: argocd namespace: kube-system spec: chart: argo-cd repo: https://argoproj.github.io/argo-helm targetNamespace: argocd set: configs.secret.argocdServerAdminPassword: \"$2y$10$IuaM9Ad1mPMycjnStOdNc.wjRlLtI8448F/hS.eA0XJLH9r/ZwRv.\" valuesContent: |- controller: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true dex: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true redis: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true server: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true ingress: enabled: true hosts: - argocd.k3s extraArgs: - --insecure reposerver: containerSecurityContext: capabilities: drop: - all readOnlyRootFilesystem: true The password in this example is argocd .","title":"Bootstrap ArgoCD using Helm"},{"location":"k3s/#bootstrap-heqet","text":"kubectl apply -f manifests/heqet-apps.yaml --- apiVersion: v1 kind: Namespace metadata: name: heqet --- apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: heqet namespace: argocd spec: destination: namespace: heqet server: 'https://kubernetes.default.svc' source: path: . repoURL: 'https://github.com/nold360/heqet' targetRevision: test helm: valueFiles: - values.yaml project: default syncPolicy: automated: prune: true selfHeal: false","title":"Bootstrap Heqet"},{"location":"k3s/#profit","text":"Now K3s should be setup: ArgoCD should be deployed by K3s-Helm-Operator The Heqet-Application will bootstrap ArgoCD ArgoCD will take control of all Application configuration in heqet","title":"Profit!"},{"location":"vault/","text":"Vault \u00b6 This are some quick notes I took on how to setup a simple Vault for usage with heqet. For a more detailed documentation on how to configure Vault, check out the Official Vault Docs . Note: Most of this commands can be executed either using the vault command on your local device or the inside the vault pod itself. Init Vault using GPG \u00b6 Copy GPG Public Key \u00b6 cat > nold.pub << EOF -----BEGIN PGP PUBLIC KEY BLOCK----- mQENBGBXTjkBCAC7qZU1cz7RWYbAb838ypRLJZKLWfVBvry4XYwWPN0Rcj55dPN+ ... 5of4H66FzNwJxYrunmM5KTeUxZiLPC1JoKMF5uvKoo59TD0IuAPq735QDjWbS4vb dMtSqTCinZSd =wuZw -----END PGP PUBLIC KEY BLOCK----- EOF Init Vault \u00b6 vault operator init -key-shares=1 -key-threshold=1 -pgp-keys=\"nold.pub\" Save Unseal Key somewhere sage e.g. Keepass \u00b6 Decode Unseal Key \u00b6 $ echo $unseal-key | base64 -d | gpg -dq Unseal Vault \u00b6 vault operator unseal Enable Kubernetes Auth \u00b6 vault auth enable kubernetes vault write auth/kubernetes/config \\ token_reviewer_jwt=\"$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\ kubernetes_host=\"https://$KUBERNETES_PORT_443_TCP_ADDR:443\" \\ kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\ disable_iss_validation=true Create Secret Store \u00b6 vault secrets enable -path=heqet kv-v2 Add Secrets-Operator Role & Policy \u00b6 Create Policy \u00b6 vault policy write heqet-app << EOF path \"heqet/+/*\" { capabilities = [\"read\"] } EOF Add Auth Role \u00b6 vault write auth/kubernetes/role/heqet-app \\ bound_service_account_names=vault-secrets-operator \\ bound_service_account_namespaces=vault-secrets-operator \\ policies=heqet-app \\ ttl=6h Add Secrets \u00b6 Remember, Secret path: heqet/<APP-NAME>/<SECRET-NAME> vault kv put heqet/argocd/argocd-secret admin.password='$2y$12$FP8OlsVj5pOOqRAhI4XPoev1STaW01uUEZGcNPQtVZmpacebNhj9i' server.secretkey=\"pDYAWK2mHa68GwwVPAsQOsG/SUT8iIo3S3FXYUWf2qM=\" vault kv put heqet/loki-stack/loki-stack-grafana admin-user=admin admin-password='grafana' vault kv put heqet/pihole/pihole-admin password=pihole vault kv put heqet/minio/minio-secret secret-key=secret access-key=access Vault-Issuer Cert-Manager via Kubernetes Service Account \u00b6 We expect you already have setup a PKI & Intermediate PKI. You will need a policy to allow your approle to create new certs: And a role: [dc = my local domain] vault write pki_int/roles/dc \\ allowed_domains=.dc \\ allow_subdomains=true \\ max_ttl=72h Policy: vault policy write pki_int - <<EOF path \"pki_int*\" { capabilities = [\"read\", \"list\"] } path \"pki_int/roles/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/sign/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/issue/dc\" { capabilities = [\"create\"] } EOF Authorize Service Account vault write auth/kubernetes/role/vault-issuer \\ bound_service_account_names=vault-issuer \\ bound_service_account_namespaces=cert-manager \\ policies=pki_int \\ ttl=6h","title":"Vault"},{"location":"vault/#vault","text":"This are some quick notes I took on how to setup a simple Vault for usage with heqet. For a more detailed documentation on how to configure Vault, check out the Official Vault Docs . Note: Most of this commands can be executed either using the vault command on your local device or the inside the vault pod itself.","title":"Vault"},{"location":"vault/#init-vault-using-gpg","text":"","title":"Init Vault using GPG"},{"location":"vault/#copy-gpg-public-key","text":"cat > nold.pub << EOF -----BEGIN PGP PUBLIC KEY BLOCK----- mQENBGBXTjkBCAC7qZU1cz7RWYbAb838ypRLJZKLWfVBvry4XYwWPN0Rcj55dPN+ ... 5of4H66FzNwJxYrunmM5KTeUxZiLPC1JoKMF5uvKoo59TD0IuAPq735QDjWbS4vb dMtSqTCinZSd =wuZw -----END PGP PUBLIC KEY BLOCK----- EOF","title":"Copy GPG Public Key"},{"location":"vault/#init-vault","text":"vault operator init -key-shares=1 -key-threshold=1 -pgp-keys=\"nold.pub\"","title":"Init Vault"},{"location":"vault/#save-unseal-key-somewhere-sage-eg-keepass","text":"","title":"Save Unseal Key somewhere sage e.g. Keepass"},{"location":"vault/#decode-unseal-key","text":"$ echo $unseal-key | base64 -d | gpg -dq","title":"Decode Unseal Key"},{"location":"vault/#unseal-vault","text":"vault operator unseal","title":"Unseal Vault"},{"location":"vault/#enable-kubernetes-auth","text":"vault auth enable kubernetes vault write auth/kubernetes/config \\ token_reviewer_jwt=\"$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" \\ kubernetes_host=\"https://$KUBERNETES_PORT_443_TCP_ADDR:443\" \\ kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\ disable_iss_validation=true","title":"Enable Kubernetes Auth"},{"location":"vault/#create-secret-store","text":"vault secrets enable -path=heqet kv-v2","title":"Create Secret Store"},{"location":"vault/#add-secrets-operator-role-policy","text":"","title":"Add Secrets-Operator Role &amp; Policy"},{"location":"vault/#create-policy","text":"vault policy write heqet-app << EOF path \"heqet/+/*\" { capabilities = [\"read\"] } EOF","title":"Create Policy"},{"location":"vault/#add-auth-role","text":"vault write auth/kubernetes/role/heqet-app \\ bound_service_account_names=vault-secrets-operator \\ bound_service_account_namespaces=vault-secrets-operator \\ policies=heqet-app \\ ttl=6h","title":"Add Auth Role"},{"location":"vault/#add-secrets","text":"Remember, Secret path: heqet/<APP-NAME>/<SECRET-NAME> vault kv put heqet/argocd/argocd-secret admin.password='$2y$12$FP8OlsVj5pOOqRAhI4XPoev1STaW01uUEZGcNPQtVZmpacebNhj9i' server.secretkey=\"pDYAWK2mHa68GwwVPAsQOsG/SUT8iIo3S3FXYUWf2qM=\" vault kv put heqet/loki-stack/loki-stack-grafana admin-user=admin admin-password='grafana' vault kv put heqet/pihole/pihole-admin password=pihole vault kv put heqet/minio/minio-secret secret-key=secret access-key=access","title":"Add Secrets"},{"location":"vault/#vault-issuer-cert-manager-via-kubernetes-service-account","text":"We expect you already have setup a PKI & Intermediate PKI. You will need a policy to allow your approle to create new certs: And a role: [dc = my local domain] vault write pki_int/roles/dc \\ allowed_domains=.dc \\ allow_subdomains=true \\ max_ttl=72h Policy: vault policy write pki_int - <<EOF path \"pki_int*\" { capabilities = [\"read\", \"list\"] } path \"pki_int/roles/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/sign/dc\" { capabilities = [\"create\", \"update\"] } path \"pki_int/issue/dc\" { capabilities = [\"create\"] } EOF Authorize Service Account vault write auth/kubernetes/role/vault-issuer \\ bound_service_account_names=vault-issuer \\ bound_service_account_namespaces=cert-manager \\ policies=pki_int \\ ttl=6h","title":"Vault-Issuer Cert-Manager via Kubernetes Service Account"},{"location":"generators/","text":"Generators \u00b6 Heqet contains a \"generators\" feature which will create additional resources for you.","title":"Generators"},{"location":"generators/#generators","text":"Heqet contains a \"generators\" feature which will create additional resources for you.","title":"Generators"},{"location":"generators/networkpolicies/","text":"NetworkPolicy \u00b6 NetworkPolicies allow you to control/deny access to or from your application. If you want to learn how NetworkPolices work, check out the Kubernetes documentation . Active Generator \u00b6 To activate the NetPol generator we simply enable it in our values.yaml : generators: networkpolicy: true Define Rules \u00b6 Next you can create/predefine NetworkPolices in values.yaml like this: networkpolicies: deny-everything: podSelector: {} policyTypes: - Egress - Ingress This rule will deny all out- [Egress] and Ingoing [Ingress] network traffic. We can define more rules ofcurse [even if 'deny-everything' is already included in 'allow-dns']: networkpolicies: deny-everything: podSelector: {} policyTypes: - Egress - Ingress allow-dns: podSelector: {} policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP to: - namespaceSelector: {} Apply NetPol to App \u00b6 Finally we can apply the NetworkPolicy to out application by appending the name of the predefined policy to the networkpolicies array: apps: - name: my-secure-app [...] networkpolicies: - deny-everything - allow-dns Allow access to/from Heqet Application \u00b6 Here is a simple way to apply rules containing other heqet apps. Lets say we have two apps: apps: - name: app-one [...] networkpolicies: - deny-app-two - name: app-two [...] So we want to deny access from app-one to app-two . In this case we can use a label that's automatically applied by heqet to every application namespace: app.heqet.gnu.one/name Our policy could look something like this: networkpolicies: deny-app-two: podSelector: {} policyTypes: - Egress egress: - to: - namespaceSelector: matchLabels: app.heqet.gnu.one/app: app-two","title":"NetworkPolicy"},{"location":"generators/networkpolicies/#networkpolicy","text":"NetworkPolicies allow you to control/deny access to or from your application. If you want to learn how NetworkPolices work, check out the Kubernetes documentation .","title":"NetworkPolicy"},{"location":"generators/networkpolicies/#active-generator","text":"To activate the NetPol generator we simply enable it in our values.yaml : generators: networkpolicy: true","title":"Active Generator"},{"location":"generators/networkpolicies/#define-rules","text":"Next you can create/predefine NetworkPolices in values.yaml like this: networkpolicies: deny-everything: podSelector: {} policyTypes: - Egress - Ingress This rule will deny all out- [Egress] and Ingoing [Ingress] network traffic. We can define more rules ofcurse [even if 'deny-everything' is already included in 'allow-dns']: networkpolicies: deny-everything: podSelector: {} policyTypes: - Egress - Ingress allow-dns: podSelector: {} policyTypes: - Egress egress: - ports: - port: 53 protocol: UDP to: - namespaceSelector: {}","title":"Define Rules"},{"location":"generators/networkpolicies/#apply-netpol-to-app","text":"Finally we can apply the NetworkPolicy to out application by appending the name of the predefined policy to the networkpolicies array: apps: - name: my-secure-app [...] networkpolicies: - deny-everything - allow-dns","title":"Apply NetPol to App"},{"location":"generators/networkpolicies/#allow-access-tofrom-heqet-application","text":"Here is a simple way to apply rules containing other heqet apps. Lets say we have two apps: apps: - name: app-one [...] networkpolicies: - deny-app-two - name: app-two [...] So we want to deny access from app-one to app-two . In this case we can use a label that's automatically applied by heqet to every application namespace: app.heqet.gnu.one/name Our policy could look something like this: networkpolicies: deny-app-two: podSelector: {} policyTypes: - Egress egress: - to: - namespaceSelector: matchLabels: app.heqet.gnu.one/app: app-two","title":"Allow access to/from Heqet Application"},{"location":"generators/vault/","text":"VaultSecret Generator \u00b6 The VaultSecret generator will create a VaultSecret for every secret specified in the secrets -hash. It's based on the vault-secret-operator . Parameters \u00b6 Parameter Type Example Description name string \"my-secret\" Name of Secret to generate & in vault [requited] keys array[string] - password Array of keys that will be pulled from the vault-secret [required] type string Opaque Secret type in Kubernetes [default: Opaque ] fromApp string myapp2 Pulls secret from another app, e.g. /heqet/<other-app>/<secret.name> . This way sharing secrets between apps is easily possible Examples \u00b6 Simple \u00b6 Here is an example for a simple secret: apps: - name: myapp secrets: - name: my-secret keys: - username - password # default: type: Opaque This will result in following resource. Notice that the path inside of Vault is /heqet/<name-of-app>/<name-of-secret> . apiVersion: ricoberger.de/v1alpha1 kind: VaultSecret metadata: name: my-secret namespace: \"myapp\" labels: app: myapp annotations: argocd.argoproj.io/sync-wave: \"-1\" spec: keys: - username - password path: heqet/myapp/my-secret type: Opaque Sharing Secrets between Apps \u00b6 Secrets can also be shared & pulled from other apps, by using the fromApp parameter: apps: - name: myapp secrets: - name: my-secret keys: - username - password - shared-key # default: type: Opaque - name: myapp2 secrets: - name: my-secret fromApp: myapp keys: - shared-key","title":"VaultSecret Generator"},{"location":"generators/vault/#vaultsecret-generator","text":"The VaultSecret generator will create a VaultSecret for every secret specified in the secrets -hash. It's based on the vault-secret-operator .","title":"VaultSecret Generator"},{"location":"generators/vault/#parameters","text":"Parameter Type Example Description name string \"my-secret\" Name of Secret to generate & in vault [requited] keys array[string] - password Array of keys that will be pulled from the vault-secret [required] type string Opaque Secret type in Kubernetes [default: Opaque ] fromApp string myapp2 Pulls secret from another app, e.g. /heqet/<other-app>/<secret.name> . This way sharing secrets between apps is easily possible","title":"Parameters"},{"location":"generators/vault/#examples","text":"","title":"Examples"},{"location":"generators/vault/#simple","text":"Here is an example for a simple secret: apps: - name: myapp secrets: - name: my-secret keys: - username - password # default: type: Opaque This will result in following resource. Notice that the path inside of Vault is /heqet/<name-of-app>/<name-of-secret> . apiVersion: ricoberger.de/v1alpha1 kind: VaultSecret metadata: name: my-secret namespace: \"myapp\" labels: app: myapp annotations: argocd.argoproj.io/sync-wave: \"-1\" spec: keys: - username - password path: heqet/myapp/my-secret type: Opaque","title":"Simple"},{"location":"generators/vault/#sharing-secrets-between-apps","text":"Secrets can also be shared & pulled from other apps, by using the fromApp parameter: apps: - name: myapp secrets: - name: my-secret keys: - username - password - shared-key # default: type: Opaque - name: myapp2 secrets: - name: my-secret fromApp: myapp keys: - shared-key","title":"Sharing Secrets between Apps"}]}